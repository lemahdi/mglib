/* C++ version of calculator */

%language "C++"
%defines
%locations

%define parser_class_name "my_parser"

%{
#include <iostream>
using namespace std;
#include "nodes.h"
%}

%parse-param { coord &cd }
%lex-param { coord &cd }

%union {
	node* nval;
	double dval;
}

/* declare tokens */
%token <nval> NAME
%token <dval> NUMBER
%token EOL

%left '+' '-'
%left '*' '/'
%nonassoc '|' UMINUS

%type <nval> exp

%start calclist

%{
extern int yylex(yy::my_parser::semantic_type *yylval,
	yy::my_parser::location_type* yyloc,
	coord &cd);

%}

%initial-action {
	// Filename for locations here
	@$.begin.filename = @$.end.filename = new std::string("stdin");
}

%%
	
exp: exp '+' exp			{ $$ = node_builder::build_node('+', $1, $3); }
	| exp '-' exp			{ $$ = node_builder::build_node('-', $1, $3); }
	| exp '*' exp			{ $$ = node_builder::build_node('*', $1, $3); }
	| exp '/' exp			{ $$ = node_builder::build_node('/', $1, $3); }
	| '|' exp				{ $$ = node_builder::build_node('|', $2, NULL); }
	| '(' exp ')'			{ $$ = $2; }
	| '-' exp %prec UMINUS	{ $$ = node_builder::build_node('M', NULL, $2); }
	| NUMBER				{ $$ = node_builder::build_num($1); }
	| NAME					{ $$ = node_builder::build_ref($1); }
;

	// bison rules for the C++ parser
calclist: /* nothing */
	| calclist exp EOL {
		cout << "= ";
		cout << node_eval::eval($2);
		dorsal::current_col++;
		cout << endl << "> ";
	}
	| calclist EOL { /* blank line or a comment */
		cout << "> ";
	}
	;
	
%%

// C++ code section of parser
namespace yy {
	void
	my_parser::error(location const &loc, const std::string& s) {
		std::cerr << "error at " << loc << ": " << s << std::endl;
	}
}